#include <stdio.h>#include <dirent.h>#include <errno.h>#include <vector>#include <string>#include <iostream>#include <regex>#include <map>#include <set>#include <fstream>#include <boost/serialization/access.hpp>#include <boost/serialization/map.hpp>#include <boost/serialization/unordered_map.hpp>#include <boost/serialization/vector.hpp>#include <boost/archive/text_iarchive.hpp>#include <boost/archive/text_oarchive.hpp>#include "OleanderStemmingLibrary-master/stemming/stemming.h"#include "OleanderStemmingLibrary-master/stemming/english_stem.h"using namespace std;set<string> stopwords = {"a", "about", "above", "after", "again", "against", "all", "am", "an", "and",                         "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being",                         "below", "between", "both", "but", "by", "can't", "cannot", "could", "couldn't",                         "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during",                         "each", "few", "for", "from", "further", "had", "hadn't", "has", "hasn't", "have",                         "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here", "here's", "hers",                         "herself", "him", "himself", "his", "how", "how's", "i", "i'd", "i'll", "i'm", "i've",                         "if", "in", "into", "is", "isn't", "it", "it's", "its", "itself", "let's", "me",                         "more", "most", "mustn't", "my", "myself", "no", "nor", "not", "of", "off", "on",                         "once", "only", "or", "other", "ought", "our", "ours", "ourselves", "out", "over",                         "own", "same", "shan't", "she", "she'd", "she'll", "she's", "should", "shouldn't",                         "so", "some", "such", "than", "that", "that's", "the", "their", "theirs", "them",                         "themselves", "then", "there", "there's", "these", "they", "they'd", "they'll",                         "they're", "they've", "this", "those", "through", "to", "too", "under", "until", "up",                         "very", "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were", "weren't",                         "what", "what's", "when", "when's", "where", "where's", "which", "while", "who", "who's",                         "whom", "why", "why's", "with", "won't", "would", "wouldn't", "you", "you'd", "you'll",                         "you're", "you've", "your", "yours", "yourself", "yourselves"};struct count_and_filenos {    friend class boost::serialization::access;    int count = 0;    vector<int> filenos = {};    template <class Archive>    void serialize(Archive & ar, const unsigned int version) {        ar & count;        ar & filenos;    }};struct index {    friend class boost::serialization::access;    map<string, vector<count_and_filenos>> m = {};    template <class Archive>    void serialize(Archive & ar, const unsigned int version) {        ar & m;    }};string find_stem(string ANSIWord) {    stemming::english_stem<> StemEnglish;    wchar_t aa[ANSIWord.length() + 1];    wchar_t* UnicodeTextBuffer = &aa[0];    wmemset(UnicodeTextBuffer, 0, ANSIWord.length()+1);    mbstowcs(UnicodeTextBuffer, ANSIWord.c_str(), ANSIWord.length());    wstring word = UnicodeTextBuffer;    StemEnglish(word);    string result;    for (char x : word)        result += x;    return result;}int read_dir(string dir, vector<string> &files, bool index) {    DIR *dp;    struct dirent *dirp;    if((dp  = opendir(dir.c_str())) == NULL) {        cout << "Error(" << errno << ") opening " << dir << endl;        return errno;    }    regex re;    if (index)        re = ".*idx$";    else        re = ".*txt$";    while ((dirp = readdir(dp)) != NULL) {        if (regex_match(string(dirp->d_name), re))            files.push_back(dir + '/' + string(dirp->d_name));    }    closedir(dp);    return 0;}void double_insort(vector<count_and_filenos> &l, count_and_filenos e) {    if (l[0].count > e.count) {        l.insert(l.begin(), e);        return;    } else if (l[l.size()-1].count < e.count) {        l.push_back(e);        return;    }    int lo = 0;    int hi = int(l.size());    int count = 10;    while (lo < hi and --count) {        int mid = (hi + lo) / 2;        if (l[mid].count == e.count) {            vector<int> &inner = l[mid].filenos;            for (int n: e.filenos)                inner.push_back(n);            return;        } else if (lo == hi - 1) {            l.insert(l.begin() + hi, e);            return;        } else if (l[mid].count > e.count) {            hi = mid;        } else if (l[mid].count < e.count) {            lo = mid;        }    }}void print_bucket(vector<count_and_filenos> bucket) {    for (count_and_filenos c: bucket) {        cout << c.count << ": [";        for (int fileno: c.filenos) {            cout << fileno << ',';        }        cout << "]" << endl;    }    cout << endl;}void print_index(struct index I) {    map<string, vector<count_and_filenos>> dict = I.m;    for (map<string, vector<count_and_filenos>>::iterator it = dict.begin(); it != dict.end(); ++it) {        string word = it->first;        cout << word << endl;        vector<count_and_filenos> bucket = it->second;        print_bucket(bucket);    }}void load_all_index(string dir_path) {    vector<string> indexnames;    read_dir(dir_path, indexnames, true);    for (string name: indexnames) {        struct index file_dict;        ifstream index_file(name);        if (index_file.is_open()) {            boost::archive::text_iarchive iarch(index_file);            iarch >> file_dict;            cout << name << endl;            print_index(file_dict);            cout << file_dict.m.size() << endl;            index_file.close();        }        cout << endl << endl;    }}void build_index(string file_dir_path, string index_dir_path, int step) {    vector<string> filenames;    read_dir(file_dir_path, filenames, false);    sort(filenames.begin(), filenames.end());    system(("mkdir " + index_dir_path).c_str());    vector<char> alphabet = {'a', 'b' ,'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',                             'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};    while (not alphabet.empty()) {        set<char> s;        if (alphabet.size() >= step) {            for (int i = 0; i < step; ++i)                s.insert(alphabet[i]);            for (int j = 0; j < step; ++j)                alphabet.erase(alphabet.begin());        } else {            for (int i = 0; i < alphabet.size(); ++i)                s.insert(alphabet[i]);            while (not alphabet.empty())                alphabet.erase(alphabet.begin());        }        struct index big_dict = {};        int file_no = 0;        for (string name : filenames) {            ifstream file(name);            map<string, int> file_dict = {};            char c;            string word;            if (file.is_open()) {                word = "";                while (file.get(c)) {                    if (isalpha(c)) {                        word.push_back(char(tolower(c)));                    } else {                        if (stopwords.find(word) == stopwords.end() and word != "" and s.find(word[0]) != s.end()) {                            word = find_stem(word);                            ++file_dict[word];                        }                        word = "";                    }                }                if (stopwords.find(word) == stopwords.end() and word != "" and s.find(word[0]) != s.end()) {                    word = find_stem(word);                    ++file_dict[word];                }                word = "";            }            for (map<string, int>::iterator it = file_dict.begin(); it != file_dict.end(); ++it) {                string w = it->first;                struct count_and_filenos bucket;                bucket.count = it->second;                bucket.filenos.push_back(file_no);                if (big_dict.m.find(w) == big_dict.m.end()) {                    big_dict.m[w].push_back(bucket);                } else {                    double_insort(big_dict.m[w], bucket);                }            }            file_dict.clear();            file.close();            ++file_no;        }        for (char c: s) {            struct index export_dict = {};            for (map<string, vector<count_and_filenos>>::iterator it = big_dict.m.begin(); it != big_dict.m.end(); ++it) {                string w = it->first;                if (w[0] == c)                    export_dict.m[w] = it->second;            }            if (export_dict.m.size() == 0)                continue;            string index_file_name(index_dir_path + "/" + c + ".idx");            ofstream index_file(index_file_name);            boost::archive::text_oarchive oarch(index_file);            oarch << export_dict;            index_file.close();        }    }}long get_file_size(string file_path) {    ifstream file(file_path, ios::ate | ios::binary);    if (file.is_open())        return file.tellg();    else        return 0;}void search(vector<string> queries, string index_dir_path, string file_dir_path) {    vector<string> filenames;    read_dir(file_dir_path, filenames, false);    sort(filenames.begin(), filenames.end());    for (int i = 0; i < queries.size(); ++i) {        for (int j = 0; j < queries[i].size(); ++j) {            queries[i][j] = char(tolower(queries[i][j]));        }        queries[i] = find_stem(queries[i]);    }    map<long, vector<string>> m;    for (string q : queries) {        long size = get_file_size(index_dir_path + '/' + q[0] + ".idx");        if (size == 0)            exit(0);        m[size].push_back(q);    }    vector<map<int, int>> all_query_res;    for (map<long, vector<string>>::iterator it = m.begin(); it != m.end(); ++it) {        vector<string> qs = it->second;        ifstream index_file(index_dir_path + '/' + qs[0][0] + ".idx");        boost::archive::text_iarchive iarchive(index_file);        struct index idx;        iarchive >> idx;        for (string q: qs) {            map<int, int> single_query_res;            if (idx.m.find(q) != idx.m.end()) {                vector<count_and_filenos> v = idx.m[q];                for (count_and_filenos c : v) {                    vector<int> fns = c.filenos;                    int n = c.count;                    for (int fn : fns)                        single_query_res[fn] = n;                }            } else {                exit(0);            }            all_query_res.push_back(single_query_res);        }    }    map<int, vector<int>> final_res;    for (int i = 0; i < filenames.size(); ++i) {        bool all_in = true;        for (map<int, int> query_map : all_query_res) {            if (query_map.find(i) == query_map.end()) {                all_in = false;                break;            }        }        if (all_in) {            int frequency = 0;            for (map<int, int> query_map : all_query_res)                frequency += query_map[i];            final_res[frequency].push_back(i);        }    }    for (map<int, vector<int>>::reverse_iterator it = final_res.rbegin(); it != final_res.rend(); ++it) {        vector<int> v = it->second;        sort(v.begin(), v.end());        for (int i : v)            cout << filenames[i] << ':' << it->first << endl;    }}int main(int argc, char *argv[]) {    string file_dir_path = argv[1];    string index_dir_path = argv[2];    vector<string> queries;    for (int i = 3; i < argc; ++i)        queries.push_back(argv[i]);    if (not opendir(index_dir_path.c_str()))        build_index(file_dir_path, index_dir_path, 9);    search(queries, index_dir_path, file_dir_path);    return 0;}